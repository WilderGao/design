# 设计模式

## 访问者模式

访问者模式，表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用域这些元素的新操作。

它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。

适用场景：适用于数据结构较为稳定的系统

访问者模式的优点就是增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。反之如果要增加新的数据结构的话，那么行为的状态类需要增加一个方法，而且他的下属类都要因此增加一个方法，这样就不够符合 开放-封闭的原则。

举例：比如说现在有两个数据结构，男人和女人，两个数据结构继承一个抽象类Person，操作分别有成功时、失败时，这两个操作继承一个抽象类BaseAction。

```java
public abstract class BaseAction {

    /**
     * 得到男人结构的反应
     * @param concreteElementA 男性类
     */
    public abstract void getManConclusion(Man concreteElementA);

    /**
     * 得到女人结构的反应
     * @param concreteElementB 女性类
     */
    public abstract void getWomanConclusion(Woman concreteElementB);

}
```

当需要增加一个新的操作时，只需要新建一个类继承BaseAction即可

当需要增加一个新的数据结构时，就需要新建一个类继承Person，而且在抽象类BaseAction中需要增加一个新的接口描述反应，而且之前那些操作都需要实现这个数据结构的接口，这样改动会很大，不符合原则。

因此，访问者模式适合数据结构比较稳定的系统

## 观察者模式
观察者模式又叫 发布-订阅模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，是他们能够自动更新自己。  

根据这我的理解，观察者模式就像有一个全局的管理人员，在安卓中的应用场景很多。当App开启一个页面的时候，就向通知者进行注册，这样的话这个页面就会得到通知者的管理，当接收到新消息的时候，全局管理员就可以方便地通知到各个页面，使各个页面可以接收到新的结果。

## 备忘录模式
备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象的外部保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。